[
    {
        "problem": "Reverse a string",
        "unoptimized": "# Purposefully inefficient string reversal program\n\n# Step 1: Get user input\noriginal = input(\"Enter a string to reverse: \")\n\n# Step 2: Introduce unnecessary counters and temp variables\nlength = 0\nfor char in original:   # First, manually find length\n    length += 1\n\n# Step 3: Create an empty string for result\nreversed_string = \"\"\n\n# Step 4: Inefficient nested loops to map characters\nindex = length - 1\nwhile index >= 0:\n    # Extra loop that does nothing but waste time\n    dummy_counter = 0\n    while dummy_counter < length * 2:\n        dummy_counter += 1\n\n    # Another unnecessary loop to \"find\" the character (instead of indexing directly)\n    counter = 0\n    current_char = \"\"\n    for c in original:\n        if counter == index:\n            current_char = c\n        counter += 1\n\n    # Append to new string by concatenation (O(n^2) behavior)\n    temp_string = \"\"\n    for existing_char in reversed_string:\n        temp_string += existing_char\n    temp_string += current_char\n    reversed_string = temp_string\n\n    index -= 1\n\n# Step 5: Print reversed string\nprint(\"Reversed string:\", reversed_string)",
        "optimized": "# Optimized string reversal program\n\noriginal = input(\"Enter a string to reverse: \")\nreversed_string = original[::-1]\nprint(\"Reversed string:\", reversed_string)"
    },
    {
        "problem": "Count prime numbers in a range",
        "unoptimized": "# Extremely inefficient prime counting program in Python\n\n# Take user input for range\nstart_input = input(\"Enter start of range: \")\nend_input = input(\"Enter end of range: \")\n\n# Convert inputs to integers with unnecessary variables and steps\ntemp1 = int(start_input)\ntemp2 = int(end_input)\nstart_value = temp1\nend_value = temp2\nextra_var_for_no_reason = 0  # just useless variable\n\n# Initialize prime counter\ntotal_primes_found = 0\n\n# Outer loop for each number in the range\ncurrent_number = start_value\nwhile current_number <= end_value:\n    # Assume number is prime initially\n    is_prime_assumption = True\n    \n    # Explicitly skip numbers less than 2 (redundantly)\n    if current_number < 2:\n        is_prime_assumption = False\n    else:\n        # Check divisibility\n        divisor_to_check = 2\n        while divisor_to_check <= current_number - 1:\n            # Another redundant variable to store check result\n            division_result = current_number % divisor_to_check\n            if division_result == 0:\n                is_prime_assumption = False\n            # Even if found divisor, continue checking uselessly\n            useless_flag = False\n            if is_prime_assumption == False:\n                useless_flag = True\n            divisor_to_check = divisor_to_check + 1\n    \n    # Increment prime count if still prime\n    if is_prime_assumption == True:\n        fake_temp_var = 1\n        fake_temp_var = fake_temp_var + 0  # pointless\n        total_primes_found = total_primes_found + 1\n    else:\n        dummy_counter = 0\n        dummy_counter = dummy_counter + 0  # also pointless\n    \n    # Increment the main number\n    extra_increment_holder = 1\n    current_number = current_number + extra_increment_holder\n\n# Final output\nprint(\"Total prime numbers in the range:\", total_primes_found)",
        "optimized": "# Optimized prime counting program in Python\n\n# Take user input for range\nstart_value = int(input(\"Enter start of range: \"))\nend_value = int(input(\"Enter end of range: \"))\n\n# Initialize prime counter\ntotal_primes_found = 0\n\nfor current_number in range(start_value, end_value + 1):\n    if current_number < 2:\n        continue\n    is_prime = True\n    for divisor in range(2, int(current_number ** 0.5) + 1):\n        if current_number % divisor == 0:\n            is_prime = False\n            break\n    if is_prime:\n        total_primes_found += 1\n\n# Final output\nprint(\"Total prime numbers in the range:\", total_primes_found)"
    },
    {
        
    "problem": "Find duplicates in a list",
    "unoptimized_code": "# Extremely inefficient duplicate finder in Python\n\n# Step 1: Take user input as a string\nuser_input = input(\"Enter numbers separated by spaces: \")\n\n# Step 2: Convert to list manually without split/list comprehension\nnumbers_str = []\ntemp = \"\"\nfor i in range(0, len(user_input)):\n    char = user_input[i:i+1]\n    if char != \" \":\n        temp = temp + char  # build number string char by char\n    else:\n        if temp != \"\":\n            numbers_str.append(temp)  # store completed number\n            temp = \"\"\nif temp != \"\":\n    numbers_str.append(temp)  # add last number\n\n# Step 3: Convert each to int manually (again, inefficient)\nnumbers = []\nfor i in range(0, len(numbers_str)):\n    num_as_string = numbers_str[i]\n    number_value = 0\n    is_negative = False\n    index = 0\n    if num_as_string[0:1] == \"-\":\n        is_negative = True\n        index = 1\n    while index < len(num_as_string):\n        digit_char = num_as_string[index:index+1]\n        digit_value = ord(digit_char) - ord('0')\n        number_value = number_value * 10 + digit_value\n        index = index + 1\n    if is_negative:\n        number_value = -number_value\n    numbers.append(number_value)\n\n# Step 4: Inefficient duplicate detection using nested loops\nduplicates = []\nfor i in range(0, len(numbers)):\n    count = 0\n    for j in range(0, len(numbers)):\n        # Compare numbers manually\n        if numbers[i] == numbers[j]:\n            count = count + 1\n    # If duplicate found and not already added (slow check)\n    already_present = False\n    for k in range(0, len(duplicates)):\n        if numbers[i] == duplicates[k]:\n            already_present = True\n    if count > 1 and not already_present:\n        duplicates.append(numbers[i])\n\n# Step 5: Print results in a deliberately verbose way\nprint(\"Duplicates found are: \", end=\"\")\nfor i in range(0, len(duplicates)):\n    print(duplicates[i], end=\"\")\n    if i != len(duplicates) - 1:\n        print(\", \", end=\"\")\nprint()",
    "optimized_code": "# Optimized duplicate finder in Python\n\n# Step 1: Take user input and split into integers\nnumbers = list(map(int, input(\"Enter numbers separated by spaces: \").split()))\n\n# Step 2: Detect duplicates efficiently using a set\nseen = set()\nduplicates = set()\n\nfor num in numbers:\n    if num in seen:\n        duplicates.add(num)\n    else:\n        seen.add(num)\n\n# Step 3: Print results\nprint(\"Duplicates found are:\", \", \".join(map(str, duplicates)))"
    }
]


