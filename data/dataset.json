[
    {
        "problem": "Reverse a string",
        "unoptimized": "# Purposefully inefficient string reversal program\n\n# Step 1: Get user input\noriginal = input(\"Enter a string to reverse: \")\n\n# Step 2: Introduce unnecessary counters and temp variables\nlength = 0\nfor char in original:   # First, manually find length\n    length += 1\n\n# Step 3: Create an empty string for result\nreversed_string = \"\"\n\n# Step 4: Inefficient nested loops to map characters\nindex = length - 1\nwhile index >= 0:\n    # Extra loop that does nothing but waste time\n    dummy_counter = 0\n    while dummy_counter < length * 2:\n        dummy_counter += 1\n\n    # Another unnecessary loop to \"find\" the character (instead of indexing directly)\n    counter = 0\n    current_char = \"\"\n    for c in original:\n        if counter == index:\n            current_char = c\n        counter += 1\n\n    # Append to new string by concatenation (O(n^2) behavior)\n    temp_string = \"\"\n    for existing_char in reversed_string:\n        temp_string += existing_char\n    temp_string += current_char\n    reversed_string = temp_string\n\n    index -= 1\n\n# Step 5: Print reversed string\nprint(\"Reversed string:\", reversed_string)",
        "optimized": "# Optimized string reversal program\n\noriginal = input(\"Enter a string to reverse: \")\nreversed_string = original[::-1]\nprint(\"Reversed string:\", reversed_string)"
    },
    {
        "problem": "Count prime numbers in a range",
        "unoptimized": "# Extremely inefficient prime counting program in Python\n\n# Take user input for range\nstart_input = input(\"Enter start of range: \")\nend_input = input(\"Enter end of range: \")\n\n# Convert inputs to integers with unnecessary variables and steps\ntemp1 = int(start_input)\ntemp2 = int(end_input)\nstart_value = temp1\nend_value = temp2\nextra_var_for_no_reason = 0  # just useless variable\n\n# Initialize prime counter\ntotal_primes_found = 0\n\n# Outer loop for each number in the range\ncurrent_number = start_value\nwhile current_number <= end_value:\n    # Assume number is prime initially\n    is_prime_assumption = True\n    \n    # Explicitly skip numbers less than 2 (redundantly)\n    if current_number < 2:\n        is_prime_assumption = False\n    else:\n        # Check divisibility\n        divisor_to_check = 2\n        while divisor_to_check <= current_number - 1:\n            # Another redundant variable to store check result\n            division_result = current_number % divisor_to_check\n            if division_result == 0:\n                is_prime_assumption = False\n            # Even if found divisor, continue checking uselessly\n            useless_flag = False\n            if is_prime_assumption == False:\n                useless_flag = True\n            divisor_to_check = divisor_to_check + 1\n    \n    # Increment prime count if still prime\n    if is_prime_assumption == True:\n        fake_temp_var = 1\n        fake_temp_var = fake_temp_var + 0  # pointless\n        total_primes_found = total_primes_found + 1\n    else:\n        dummy_counter = 0\n        dummy_counter = dummy_counter + 0  # also pointless\n    \n    # Increment the main number\n    extra_increment_holder = 1\n    current_number = current_number + extra_increment_holder\n\n# Final output\nprint(\"Total prime numbers in the range:\", total_primes_found)",
        "optimized": "# Optimized prime counting program in Python\n\n# Take user input for range\nstart_value = int(input(\"Enter start of range: \"))\nend_value = int(input(\"Enter end of range: \"))\n\n# Initialize prime counter\ntotal_primes_found = 0\n\nfor current_number in range(start_value, end_value + 1):\n    if current_number < 2:\n        continue\n    is_prime = True\n    for divisor in range(2, int(current_number ** 0.5) + 1):\n        if current_number % divisor == 0:\n            is_prime = False\n            break\n    if is_prime:\n        total_primes_found += 1\n\n# Final output\nprint(\"Total prime numbers in the range:\", total_primes_found)"
    }
]
